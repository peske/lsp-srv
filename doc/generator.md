# Generator usage

This module exposes LSP server handler generator which is originally available in
`golang.org/x/tools/gopls/internal/lsp/helper` directory. It generates an implementation of
[`protocol.Server` interface](../protocol/tsserver.go#L18) based on your code.

## Create the generator

To create the generator you should implement a temporary `main` package with `main()` function:

```go
package main

import "github.com/peske/lsp-srv/lsp/helper"

func main() {
	helper.Generate()
}
```

Then build the file:

```bash
go build -o lspgen
```

Now you should have `lspgen` executable in the working directory, and you can delete the temporary code.

> **Note:** You should create a new generator whenever you update the version of `github.com/peske/lsp-srv` module.

## Prepare the custom code

Somewhere in your project you should have `lsp` package/directory. The generator will search for the implementations in
`lsp` package, so the name matters - it has to be `lsp`. In this package you should create several things:

- Type that will handle the communication, as explained in [README](./README.md).
- A function with the signature `notImplemented(method string) error`. It will be called whenever LSP method call that
  you haven't implemented happens.
- Add `//go:generate` instruction that will add all the methods defined by `protocol.Server` interface to your type.

For example, we will use the same `Server` type we've created in [README](./README.md#create-a-type), and just add one
more function and `//go:generate` at the end of the file:

```go
package lsp

import (
	"context"
	
	"github.com/peske/lsp-srv/lsp/protocol"
)

// Server is the type.
type Server struct {
	client protocol.ClientCloser
	ctx    context.Context
	cancel func()
}

// NewServer is the factory function.
func NewServer(client protocol.ClientCloser, ctx context.Context, cancel func()) *Server {
	return &Server{
		client: client,
		ctx:    ctx,
		cancel: cancel,
    }
}

// notImplemented is the function mentioned in the instructions above. 
func notImplemented(method string) error {
  return fmt.Errorf("'%s' not implemented", method)
}

// go generate instruction mentioned in the instructions above.
//go:generate ../lspgen -o server_gen.go -t Server -u .
```

Explanations of `//go:generate` line:

- We are assuming that `lspgen` executable is in the root project directory, which is parent directory of our `lsp`
  package, so we're specifying it as `../lspgen`.
- We want the output file to be named `server_gen.go` and reside in the same directory as this file (`server.go`), so we
  are specifying `-o server_gen.go`
- The type we're using is `Server`, so we're specifying `-t Server`. This argument is optional, and it will default to
  `Server` if not specified.
- We want the generator to search for the custom implementations in this directory (in `lsp` directory), that's why
  we're specifying `-u .`

Finally, we should execute `go generate`. If we're executing it from the root directory, we should _tell it_ to search
through subdirectories:

```bash
go generate ./...
```

If everything done correctly, the previous command will create `./lsp/server_gen.go` file that contains all the methods
specified by the [`protocol.Server` interface](../protocol/tsserver.go#L18). Here's a part of the file that contains
only first two methods:

```go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lsp

// code generated by helper. DO NOT EDIT.

import (
	"context"
	
	"github.com/peske/lsp-srv/lsp/protocol"
)

func (s *Server) CodeAction(context.Context, *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	return nil, notImplemented("CodeAction")
}

func (s *Server) CodeLens(context.Context, *protocol.CodeLensParams) ([]protocol.CodeLens, error) {
	return nil, notImplemented("CodeLens")
}
```

## Actual LSP method implementation

Generated interface implementation from above contains a bunch of methods that simply call `notImplemented` function. In
reality, we need to have at least some of these methods implemented. To accomplish this you need to write the actual
method implementations somewhere in your `lsp` package. For example, let's say that you want to implement `CodeAction`
method. From the generated code above you can see that the signature of this method is:

```go
func (s *Server) CodeAction(context.Context, *protocol.CodeActionParams) ([]protocol.CodeAction, error)
```

You should create the actual implementation method with the same signature, and the same name, but with lowercase first
letter:

```go
func (s *Server) codeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	// Your actual implementation goes here...
	return nil, errors.New("just kidding - not implemented yet")
}
```

You can put this function in any file in your `lsp` package and the generator will find it. After that, and after
running the generator again, the generated code will contain:

```go
func (s *Server) CodeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	return s.codeAction(ctx, params)
}
```

In short, you can create only the methods you actually want to implement. Generator will take care of the boilerplate
for the rest.
