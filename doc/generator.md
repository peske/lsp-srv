# Generator usage

This module exposes LSP server handler generator which is originally available in
`golang.org/x/tools/gopls/internal/lsp/helper` directory. It generates an implementation of
[`protocol.Server` interface](../protocol/tsserver.go#L18) based on your code.

## Create the generator

To create the generator you should implement a temporary `main` package with `main()` function:

```go
package main

import "github.com/peske/lsp/helper"

func main() {
	helper.Generate()
}
```

Then build the file:

```bash
go build -o lspgen
```

Now you should have `lspgen` executable in the working directory, and you can delete the temporary code.

> **Note:** You should create a new generator whenever you update the version of `github.com/peske/lsp` module.

## Prepare the custom code

Somewhere in your project you should have `lsp` package/directory. Note that the name matters - it has to be `lsp`. In
this package you should create several things:

- Type that will be used as LSP server handler. In the simplest case it can be a structure without any fields, like
  `type Server struct{}`. You can add custom fields to this type if you need them.
- Function `func notImplemented(method string) error` that will be called for LSP methods that you haven't implemented.
- Add `//go:generate` instruction.

For example, let's say that your `lsp` package is in a subdirectory `./lsp` in your project. Minimal implementation
would be to create a Go file (let's say `./lsp/server.go`) with the following content:

```go
package lsp

import "fmt"

type Server struct{}

func notImplemented(method string) error {
  return fmt.Errorf("'%s' not implemented", method)
}

//go:generate ../lspgen -o server_gen.go -u .
```

Explanations of `//go:generate` line:

- We are assuming that `lspgen` executable is in the root project directory, which is parent directory of our `lsp`
  package, so we're specifying it as `../lspgen`.
- We want the output file to be named `server_gen.go` and reside in the same directory as this file (`server.go`), so we
  are specifying `-o server_gen.go`
- We want the generator to search for the custom implementations in this directory (in `lsp` directory), that's why
  we're specifying `-u .`

Finally, we should execute `go generate`. If we're executing it from the root directory, we should _tell it_ to search
through subdirectories:

```bash
go generate ./...
```

If everything done correctly, the previous command will create `./lsp/server_gen.go` file that contains all the methods
specified by the [`protocol.Server` interface](../protocol/tsserver.go#L18). Here's a part of the file that contains
only first two methods:

```go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lsp

// code generated by helper. DO NOT EDIT.

import (
	"context"

	"github.com/peske/lsp/protocol"
)

func (s *Server) CodeAction(context.Context, *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	return nil, notImplemented("CodeAction")
}

func (s *Server) CodeLens(context.Context, *protocol.CodeLensParams) ([]protocol.CodeLens, error) {
	return nil, notImplemented("CodeLens")
}
```

## Actual LSP method implementation

Generated interface implementation from above contains a bunch of methods that simply call `notImplemented` function. In
reality, we need to have at least some of these methods implemented. To accomplish this you need to write the actual
method implementations somewhere in your `lsp` package. For example, let's say that you want to implement `CodeAction`
method. From the generated code above you can see that the signature of this method is:

```go
func (s *Server) CodeAction(context.Context, *protocol.CodeActionParams) ([]protocol.CodeAction, error)
```

You should create the actual implementation method with the same signature, and the same name, but with lowercase first
letter:

```go
func (s *Server) codeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	// Your actual implementation goes here...
	return nil, errors.New("just kidding - not implemented yet")
}
```

You can put this function in any file in your `lsp` package - generator will find it. After such implementation is
created, and after running the generator again, the generated code will contain:

```go
func (s *Server) CodeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	return s.codeAction(ctx, params)
}
```

In short, you can create only the methods you actually want to implement. Generator will take care of the boilerplate
for the rest.
