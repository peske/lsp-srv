# Generator usage

This module exposes LSP server handler generator which is originally available in
`golang.org/x/tools/gopls/internal/lsp/helper` directory. It generates an implementation of
[`protocol.Server` interface](../protocol/tsserver.go#L18) based on your code.

## Create the generator

To create the generator you should implement a temporary `main` package with `main()` function:

```go
package main

import "github.com/peske/lsp-srv/lsp/helper"

func main() {
	helper.Generate()
}
```

Then build the file:

```bash
go build -o lspgen
```

Now you should have `lspgen` executable in the working directory, and you can delete the temporary code.

> **Note:** You should create a new generator whenever you update the version of `github.com/peske/lsp-srv` module.

## Prepare the custom code

Somewhere in your project you should have `lsp` package/directory. Note that the name matters - it has to be `lsp`. In
this package you should create several things:

- Type that will be used as LSP server handler. This type should at least contain one field of type
  `protocol.ClientCloser`, although you can add as many additional fields as you need.
- A function with the signature `notImplemented(method string) error`. It will be called whenever LSP method call that
  you haven't implemented happens.
- Factory function that accepts one argument of type `protocol.ClientCloser`, and returns an instance of the type you've
  created in the previous steps.
- Add `//go:generate` instruction that will add all the methods defined by `protocol.Server` interface to your type.

For example, let's say that your `lsp` package is in a subdirectory `./lsp` in your project. Minimal implementation
would be to create a Go file (let's say `./lsp/server.go`) with the following content:

```go
package lsp

import (
  "fmt"
  
  "github.com/peske/lsp-srv/lsp/protocol"
)

// Server is the type mentioned in the instructions. 
type Server struct {
  client protocol.ClientCloser
}

// NewServer is the factory function mentioned in the instructions.
func NewServer(client protocol.ClientCloser) *Server {
	return &Server{client: client}
}

// notImplemented is the function mentioned in the instructions. 
func notImplemented(method string) error {
  return fmt.Errorf("'%s' not implemented", method)
}

// go generate instruction mentioned in the instructions.
//go:generate ../lspgen -o server_gen.go -u .
```

Explanations of `//go:generate` line:

- We are assuming that `lspgen` executable is in the root project directory, which is parent directory of our `lsp`
  package, so we're specifying it as `../lspgen`.
- We want the output file to be named `server_gen.go` and reside in the same directory as this file (`server.go`), so we
  are specifying `-o server_gen.go`
- We want the generator to search for the custom implementations in this directory (in `lsp` directory), that's why
  we're specifying `-u .`

Finally, we should execute `go generate`. If we're executing it from the root directory, we should _tell it_ to search
through subdirectories:

```bash
go generate ./...
```

If everything done correctly, the previous command will create `./lsp/server_gen.go` file that contains all the methods
specified by the [`protocol.Server` interface](../protocol/tsserver.go#L18). Here's a part of the file that contains
only first two methods:

```go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lsp

// code generated by helper. DO NOT EDIT.

import (
	"context"
	
	"github.com/peske/lsp-srv/lsp/protocol"
)

func (s *Server) CodeAction(context.Context, *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	return nil, notImplemented("CodeAction")
}

func (s *Server) CodeLens(context.Context, *protocol.CodeLensParams) ([]protocol.CodeLens, error) {
	return nil, notImplemented("CodeLens")
}
```

## Actual LSP method implementation

Generated interface implementation from above contains a bunch of methods that simply call `notImplemented` function. In
reality, we need to have at least some of these methods implemented. To accomplish this you need to write the actual
method implementations somewhere in your `lsp` package. For example, let's say that you want to implement `CodeAction`
method. From the generated code above you can see that the signature of this method is:

```go
func (s *Server) CodeAction(context.Context, *protocol.CodeActionParams) ([]protocol.CodeAction, error)
```

You should create the actual implementation method with the same signature, and the same name, but with lowercase first
letter:

```go
func (s *Server) codeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	// Your actual implementation goes here...
	return nil, errors.New("just kidding - not implemented yet")
}
```

You can put this function in any file in your `lsp` package and the generator will find it. After that, and after
running the generator again, the generated code will contain:

```go
func (s *Server) CodeAction(ctx context.Context, params *protocol.CodeActionParams) ([]protocol.CodeAction, error) {
	return s.codeAction(ctx, params)
}
```

In short, you can create only the methods you actually want to implement. Generator will take care of the boilerplate
for the rest.

### Required LSP method implementation

As already mentioned above, you'll implement only methods that you need for your use case. But in any case you have to
implement at least `Initialize` method, to report the _capabilities_ of the server you're developing. But explaining
this is outside the scope of our documentation - this is a part of
[LSP specification](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/).
